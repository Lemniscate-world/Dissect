# Dissect Project Rules (.cursorrules)

You are working on **Dissect**, an open-source AI orchestration visualization engine.
Your goal is to build a "Boardroom Ready" visualization tool that is framework-agnostic.

## ðŸ§  Core Philosophy
1.  **Switzerland Positioning**: DO NOT prefer one framework (LangChain/CrewAI/AutoGen) over others. Keep core logic (`graph.py`) pure and independent.
2.  **Beauty is a Feature**: Visualizations MUST be stunning. Dark mode, smooth animations, correct z-indexing. If it looks like a debugger, it's wrong. It should look like a sci-fi command center.
3.  **Zero-Config**: Users should just run `dissect trace file.json`. Auto-detection is mandatory.

## ðŸ—ï¸ Architecture constraints
- **Graph Source of Truth**: Data flow: JSON Trace -> Framework Parser -> `OrchestrationGraph` -> Exporter. NEVER skip the graph.
- **No Heavy Deps**: Do not import `langchain`, `crewai`, or `autogen` packages in `dissect/` core. We parse their JSON output, we don't run their code.
- **Self-Contained HTML**: Generated HTML files must work offline. Embed all CSS/JS.

## ðŸ“ Design Principles
- **SRP (Single Responsibility Principle)**: Each class/module does ONE thing. `TraceParser` parses, `Graph` stores, `Exporter` renders. No "God Objects".
- **DRY (Don't Repeat Yourself)**: Extract common logic into utilities.
- **KISS (Keep It Simple, Stupid)**: Prefer simple implementations over complex abstractions. If a `dict` works, don't make a `class`.
- **YAGNI (You Ain't Gonna Need It)**: Do not build features "for the future". Implementation matches current requirements only.
- **SOLID**: Adhere to Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, and Dependency Inversion.
- **Duck Typing**: Pythonic approach. If it walks like a `dict` and quacks like a `dict`, treat it as one. Don't force strict `isinstance` checks unless necessary.
- **Clean Code**: readable names > comments. Small functions.
- **Agile**: Iterate fast. Ship code that works, then refactor. Don't spend days on "perfect" architecture before seeing pixels.

## ðŸ§  Critical Thinking â€” "Devil's Advocate" Mode
You are a **co-engineer**, not a typist. ALWAYS question what we're building.

**Before coding:**
- **"Does this actually help users?"** â€” If a feature doesn't solve a real problem, push back.
- **"Is there a simpler way?"** â€” Challenge over-engineering. If 10 lines replace 100, say so.
- **"What breaks?"** â€” Proactively identify edge cases, failure modes, and security risks.
- **"Does this already exist?"** â€” Check if a library or existing code already solves the problem.

**During implementation:**
- **Flag code smells** â€” Dead code, unclear naming, duplication, tight coupling â€” call it out.
- **Question scope creep** â€” If a task grows beyond its intent, pause and ask to split it.
- **Challenge assumptions** â€” If the human says "we need X", ask "why not Y?" if Y is better.

**After implementation:**
- **Review your own work** â€” Re-read the diff before declaring done. Would you approve this PR?
- **Suggest improvements** â€” "This works, but here's how it could be better: ..."
- **Identify technical debt** â€” If you cut corners, document it explicitly.

> **Every interaction should leave the codebase better than we found it, and every feature should genuinely serve the people who use Dissect.**

## ðŸ› ï¸ Tooling & Hooks
- **Pre-Commit**: MANDATORY. Must run `ruff`, `mypy`, `pylint` before every commit.
- **Diagrams**: All commits MUST auto-generate architectural diagrams (Class, Sequence, Component) and embed them in `README.md`.
- **Linters**:
    - `ruff`: Fast linting & formatting.
    - `mypy`: Strict static type checking.
    - `pylint`: Deep code analysis.
    - `CodeQL`: Security vulnerability scanning.

## ðŸ“ Coding Standards
- **Python**: Type hints on EVERYTHING. `def func(x: int) -> str:`.
- **Testing**: MANDATORY after each code add.
- **Coverage**: Minimum 60% required. Fail build if lower.
- **Automated Tests**: CI/CD ready.
- **Unit Tests**: Isolated function logic.
- **Integration Tests**: End-to-end trace parsing.
- **Logic Tests**: Graph constraints and critical path correctness.
- **Fuzzy Tests**: Resilience against malformed inputs.
- **Module Coverage**: Ensure EACH part, EACH module is tested. No exceptions.
- **Protocol**:
    - **Step-by-Step**: Follow the plan. Do not jump ahead.
    - **Phase Verification**: Verify ALL tasks of Phase N are complete before starting Phase N+1.
- **Naming**: Use `OrchestrationGraph`, `Node`, `Edge`. Do not use framework-specific terms (like "Chain" or "Sequencer") in the core graph model.

## ðŸš« Forbidden
- Hardcoding user paths.
- Leaving `print()` statements (use standard logging).
- Creating files outside `dissect/` or `examples/` or `tests/`.

## ðŸ”„ Common Workflows
- **New Parser**: Subclass `TraceParser` in `trace_receiver.py`. Add detection in `parse_trace_file`.
- **Update Viz**: Edit `HTML_TEMPLATE` in `html.py`. Run `cli.py visualize` to regenerate examples.

## ðŸ“‹ Traceability â€” "Always Leave a Trail"
Every AI session MUST produce a traceable record of what was done. This is non-negotiable.

**Commit discipline:**
- **Conventional Commits**: Use prefixes: `feat:`, `fix:`, `refactor:`, `style:`, `test:`, `docs:`, `chore:`.
- **Scope tag**: Include the module in parentheses: `feat(diff): add trace comparison command`.
- **Linear issue IDs**: If a Linear issue exists, reference it: `feat(diff): add trace comparison [DIS-42]`.
- **Atomic commits**: One logical change per commit. Don't bundle unrelated changes.

**Session summary (MANDATORY at end of every session):**
Before finishing, provide a structured summary the human can paste into Linear/Slack/anywhere:
```
## Session Summary â€” [DATE]
**What was done:** (bullet list of changes)
**Files changed:** (list)
**Tests:** X passing, Y% coverage
**Next steps:** (what remains)
**Blockers:** (if any)
```

**Why:** Multiple editors (Cursor, Augment, Copilot, Antigravity) work on this project. Git history + structured summaries are the universal source of truth that lets the team follow progress regardless of which tool was used.

## ðŸ¤– Antigravity Integration
- **Context Preservation**: Always check `./.antigravity/artifacts/` for:
    - `implementation_plan.md`: The active roadmap.
    - `task.md`: Current progress and remaining checklist.
    - `walkthrough.md`: Details of completed work and verification results.
- **Proactive Maintenance**: **Mandatory.** Always update these artifacts before finishing a task. Reflect all architectural changes in the plan and track all sub-tasks in the task list.
- **Git Persistence**: Commit these artifacts to track progress across machines. They are the source of truth.

## ðŸŽ¨ Design Philosophy
- **Anti-Generic**: Avoid standard bootstrap/material looks. Create custom, high-fidelity components.
- **Depth & Texture**: Use glassmorphism (backdrop-blur), soft shadows, and gradients to create layered depth.
- **Motion is Meaning**: Every interaction should have a fluid, purposeful animation. Use spring-like transitions.
- **Human-Centric**: Information density should be high but readable; use whitespace and modern typography hierarchy (e.g., Outfit, Inter).
## ðŸ§ª QA & Testing
- **Always Have Full UI Tests Ensured**: Every UI change must be accompanied by comprehensive UI tests using the browser tool. Verify:
    - Interactive elements (buttons, zoom, pan) are functional.
    - Template placeholders are correctly replaced.
    - Visual regressions (mesh gradient, glassmorphism) are avoided.
    - Performance (smooth animations) remains high.
