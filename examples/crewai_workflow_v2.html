<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dissect - Research & Writing Crew</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #eee;
            height: 100vh;
            overflow: hidden;
        }
        header {
            background: rgba(0,0,0,0.5);
            padding: 0.8rem 1.5rem;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 100;
            position: relative;
            backdrop-filter: blur(10px);
        }
        header h1 { font-size: 1.2rem; font-weight: 500; }
        header h1 span { color: #00d4ff; font-weight: 700; }
        
        .controls { display: flex; gap: 10px; }
        button {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: #fff;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s;
        }
        button:hover { background: rgba(255,255,255,0.2); }
        button.primary { background: #00d4ff; color: #000; border: none; font-weight: 600; }
        button.primary:hover { background: #00b0d4; }
        
        .container { display: flex; height: 100%; position: relative; }
        
        #graph-viewport { 
            flex: 1; 
            position: relative; 
            overflow: hidden; 
            cursor: grab;
            background-image: radial-gradient(rgba(255,255,255,0.05) 1px, transparent 1px);
            background-size: 20px 20px;
        }
        #graph-viewport:active { cursor: grabbing; }
        
        #graph-content { 
            position: absolute; 
            top: 0; 
            left: 0; 
            transform-origin: 0 0;
            pointer-events: none;
        }
        
        #sidebar {
            width: 300px;
            background: rgba(0,0,0,0.3);
            border-left: 1px solid rgba(255,255,255,0.1);
            padding: 1rem;
            overflow-y: auto;
            backdrop-filter: blur(10px);
            z-index: 10;
        }
        
        .node {
            position: absolute;
            padding: 10px 14px;
            border-radius: 8px;
            cursor: pointer;
            pointer-events: auto;
            min-width: 140px;
            text-align: center;
            font-size: 0.85rem;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275), box-shadow 0.3s, opacity 0.3s;
            user-select: none;
        }
        .node:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 20px rgba(0,0,0,0.5);
            z-index: 10;
        }
        .node.selected { 
            outline: 2px solid #00d4ff; 
            box-shadow: 0 0 20px rgba(0,212,255,0.3);
        }
        .node.dimmed { opacity: 0.2; }
        .node.active { box-shadow: 0 0 30px rgba(255,255,255,0.5); transform: scale(1.1); z-index: 20; }
        
        .node-agent { background: linear-gradient(135deg, #0288d1, #01579b); }
        .node-tool { background: linear-gradient(135deg, #f57c00, #e65100); }
        .node-llm_call { background: linear-gradient(135deg, #7b1fa2, #4a148c); }
        .node-user_input { background: linear-gradient(135deg, #388e3c, #1b5e20); }
        .node-output { background: linear-gradient(135deg, #d32f2f, #b71c1c); }
        .node-unknown { background: linear-gradient(135deg, #546e7a, #37474f); }
        
        .node .name { font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 180px; }
        .node .duration { font-size: 0.7rem; opacity: 0.7; margin-top: 4px; font-family: monospace; }
        
        svg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; overflow: visible; }
        svg path { 
            stroke: rgba(255,255,255,0.2); 
            stroke-width: 2; 
            fill: none; 
            transition: stroke 0.3s;
        }
        svg path.active { stroke: #00d4ff; stroke-width: 3; filter: drop-shadow(0 0 5px #00d4ff); }
        
        .info-panel h3 { margin-bottom: 1rem; color: #00d4ff; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 1px; }
        .info-item { margin-bottom: 1rem; background: rgba(255,255,255,0.05); padding: 10px; border-radius: 6px; }
        .info-item label { font-size: 0.7rem; color: #888; display: block; margin-bottom: 4px; }
        .info-item span { font-size: 0.9rem; word-break: break-all; }
        
        .playback-bar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(10px);
            padding: 10px 20px;
            border-radius: 30px;
            display: flex;
            align-items: center;
            gap: 15px;
            border: 1px solid rgba(255,255,255,0.1);
            z-index: 100;
        }
        .progress-container { width: 300px; height: 6px; background: rgba(255,255,255,0.1); border-radius: 3px; cursor: pointer; position: relative; }
        .progress-bar { height: 100%; background: #00d4ff; border-radius: 3px; width: 0%; transition: width 0.1s linear; }
        .time-display { font-family: monospace; font-size: 0.8rem; min-width: 60px; }
        
    </style>
</head>
<body>
    <header>
        <h1><span>Dissect</span> Research & Writing Crew</h1>
        <div class="controls">
            <button onclick="resetZoom()">Reset View</button>
            <button onclick="toggleTheme()">Theme</button>
        </div>
    </header>
    <div class="container">
        <div id="graph-viewport">
            <div id="graph-content">
                <svg id="edges"></svg>
                <div id="nodes"></div>
            </div>
        </div>
        <div id="sidebar">
            <div class="info-panel">
                <h3>Workflow Info</h3>
                <div class="info-item">
                    <label>Total Nodes</label>
                    <span id="info-nodes">5</span>
                </div>
                <div class="info-item">
                    <label>Critical Path Duration</label>
                    <span id="info-duration">420000ms</span>
                </div>
            </div>
            <div id="node-details" style="display:none; margin-top: 2rem;">
                <h3>Node Details</h3>
                <div class="info-item">
                    <label>Name</label>
                    <span id="detail-name">-</span>
                </div>
                <div class="info-item">
                    <label>Type</label>
                    <span id="detail-type">-</span>
                </div>
                <div class="info-item">
                    <label>Duration</label>
                    <span id="detail-duration">-</span>
                </div>
                <div class="info-item">
                    <label>Metadata</label>
                    <span id="detail-meta" style="font-family:monospace; font-size:0.8rem">-</span>
                </div>
            </div>
        </div>
    </div>
    
    <div class="playback-bar">
        <button id="play-btn" class="primary" onclick="togglePlayback()">▶ Play</button>
        <div class="progress-container" onclick="seek(event)">
            <div class="progress-bar" id="progress"></div>
        </div>
        <div class="time-display" id="time-display">00:00</div>
    </div>

    <script>
        const graphData = {
  "name": "Research & Writing Crew",
  "nodes": [
    {
      "id": "crew-001",
      "name": "Research & Writing Crew",
      "type": "agent",
      "start_time": 1770631200.0,
      "end_time": 1770631500.0,
      "duration_ms": 300000.0,
      "metadata": {
        "type": "crew"
      }
    },
    {
      "id": "agent-researcher",
      "name": "Senior Researcher",
      "type": "agent",
      "start_time": null,
      "end_time": null,
      "duration_ms": null,
      "metadata": {
        "goal": "Find accurate information about AI trends",
        "backstory": "Expert researcher with 10 years experience",
        "tools": [
          "web_search",
          "wikipedia"
        ]
      }
    },
    {
      "id": "agent-writer",
      "name": "Technical Writer",
      "type": "agent",
      "start_time": null,
      "end_time": null,
      "duration_ms": null,
      "metadata": {
        "goal": "Write clear and engaging content",
        "backstory": "Published author and tech blogger",
        "tools": [
          "text_editor"
        ]
      }
    },
    {
      "id": "task-research",
      "name": "Research the latest AI agent frameworks",
      "type": "agent",
      "start_time": 1770631230.0,
      "end_time": 1770631350.0,
      "duration_ms": 120000.0,
      "metadata": {
        "description": "Research the latest AI agent frameworks",
        "expected_output": "A summary of top 5 AI agent frameworks",
        "agent": "Senior Researcher",
        "output": "Top frameworks: LangChain, CrewAI, AutoGen, Semantic Kernel, DSPy"
      }
    },
    {
      "id": "task-write",
      "name": "Write a blog post about AI agents",
      "type": "agent",
      "start_time": 1770631350.0,
      "end_time": 1770631470.0,
      "duration_ms": 120000.0,
      "metadata": {
        "description": "Write a blog post about AI agents",
        "expected_output": "A 500-word blog post",
        "agent": "Technical Writer",
        "output": "The Rise of AI Agents: A comprehensive overview..."
      }
    }
  ],
  "edges": [
    {
      "source": "crew-001",
      "target": "agent-researcher",
      "label": null,
      "metadata": {}
    },
    {
      "source": "crew-001",
      "target": "agent-writer",
      "label": null,
      "metadata": {}
    },
    {
      "source": "crew-001",
      "target": "task-research",
      "label": null,
      "metadata": {}
    },
    {
      "source": "crew-001",
      "target": "task-write",
      "label": null,
      "metadata": {}
    }
  ],
  "metadata": {}
};
        const viewport = document.getElementById('graph-viewport');
        const content = document.getElementById('graph-content');
        const svg = document.getElementById('edges');
        const nodesContainer = document.getElementById('nodes');
        
        // State
        let scale = 1;
        let pannedX = 0;
        let pannedY = 0;
        let isDragging = false;
        let startX, startY;
        let isPlaying = false;
        let animationTime = 0;
        let maxTime = 0;
        let animationFrame;
        
        // Initialize
        function init() {
            // Calculate max time for playback
            const timestamps = graphData.nodes
                .map(n => [n.start_time, n.end_time])
                .flat()
                .filter(t => t);
            
            if (timestamps.length > 0) {
                const minTime = Math.min(...timestamps);
                graphData.nodes.forEach(n => {
                    if (n.start_time) n.relativeStart = (n.start_time - minTime) * 1000;
                    if (n.end_time) n.relativeEnd = (n.end_time - minTime) * 1000;
                });
                maxTime = Math.max(...graphData.nodes.map(n => n.relativeEnd || 0));
            } else {
                // Fallback if no timestamps
                graphData.nodes.forEach((n, i) => {
                    n.relativeStart = i * 100;
                    n.relativeEnd = (i + 1) * 100;
                });
                maxTime = graphData.nodes.length * 100;
            }
            
            layoutAndRender();
            centerGraph();
            setupInteractions();
        }
        
        function layoutAndRender() {
            // Simple Tree Layout
            const levels = {};
            const nodeMap = {};
            graphData.nodes.forEach(n => nodeMap[n.id] = n);
            
            const targets = new Set(graphData.edges.map(e => e.target));
            const roots = graphData.nodes.filter(n => !targets.has(n.id));
            
            // Assign levels
            const queue = roots.map(r => ({ id: r.id, level: 0 }));
            const visited = new Set();
            const nodeLevels = {};
            
            while (queue.length > 0) {
                const { id, level } = queue.shift();
                if (visited.has(id)) continue;
                visited.add(id);
                nodeLevels[id] = level;
                
                if (!levels[level]) levels[level] = [];
                levels[level].push(id);
                
                graphData.edges.filter(e => e.source === id).forEach(e => {
                    queue.push({ id: e.target, level: level + 1 });
                });
            }
            
            // Render Nodes
            const levelHeight = 150;
            const nodePositions = {};
            
            Object.entries(levels).forEach(([level, ids]) => {
                const width = ids.length * 180;
                ids.forEach((id, i) => {
                    // Center the level
                    const x = (i * 180) - (width / 2) + 90;
                    const y = level * levelHeight + 50;
                    nodePositions[id] = { x, y };
                    
                    const node = nodeMap[id];
                    const div = document.createElement('div');
                    div.className = `node node-${node.type}`;
                    div.id = `node-${id}`;
                    div.style.left = x + 'px';
                    div.style.top = y + 'px';
                    div.innerHTML = `
                        <div class="name">${node.name}</div>
                        ${node.duration_ms ? `<div class="duration">${node.duration_ms.toFixed(0)}ms</div>` : ''}
                    `;
                    div.onclick = (e) => selectNode(node, div, e);
                    nodesContainer.appendChild(div);
                });
            });
            
            // Render Edges (Curved Bezier)
            graphData.edges.forEach(edge => {
                const start = nodePositions[edge.source];
                const end = nodePositions[edge.target];
                if (start && end) {
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    // Anchor points helper
                    const sx = start.x + 70; // half width
                    const sy = start.y + 40; // bottom of node approx
                    const ex = end.x + 70;
                    const ey = end.y;
                    
                    // Bezier curve
                    const c1x = sx;
                    const c1y = sy + 50;
                    const c2x = ex;
                    const c2y = ey - 50;
                    
                    const d = `M ${sx} ${sy} C ${c1x} ${c1y}, ${c2x} ${c2y}, ${ex} ${ey}`;
                    
                    path.setAttribute('d', d);
                    path.id = `edge-${edge.source}-${edge.target}`;
                    svg.appendChild(path);
                }
            });
        }
        
        function selectNode(node, el, e) {
            e.stopPropagation();
            document.querySelectorAll('.node').forEach(n => n.classList.remove('selected'));
            el.classList.add('selected');
            
            document.getElementById('node-details').style.display = 'block';
            document.getElementById('detail-name').textContent = node.name;
            document.getElementById('detail-type').textContent = node.type;
            document.getElementById('detail-duration').textContent = node.duration_ms ? node.duration_ms.toFixed(0) + 'ms' : '-';
            document.getElementById('detail-meta').textContent = JSON.stringify(node.metadata, null, 2);
        }
        
        // Zoom & Pan Logic
        function setupInteractions() {
            viewport.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                scale = Math.min(Math.max(0.1, scale * delta), 5);
                updateTransform();
            });
            
            viewport.addEventListener('mousedown', (e) => {
                if (e.target === viewport || e.target === content || e.target.tagName === 'svg') {
                    isDragging = true;
                    startX = e.clientX - pannedX;
                    startY = e.clientY - pannedY;
                    viewport.style.cursor = 'grabbing';
                }
            });
            
            window.addEventListener('mouseup', () => {
                isDragging = false;
                viewport.style.cursor = 'grab';
            });
            
            window.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    pannedX = e.clientX - startX;
                    pannedY = e.clientY - startY;
                    updateTransform();
                }
            });
        }
        
        function updateTransform() {
            content.style.transform = `translate(${pannedX}px, ${pannedY}px) scale(${scale})`;
        }
        
        function centerGraph() {
            const bbox = content.getBoundingClientRect();
            // Initial center
            pannedX = viewport.offsetWidth / 2;
            pannedY = 50;
            scale = 0.8;
            updateTransform();
        }
        
        function resetZoom() {
            centerGraph();
        }
        
        // Playback Logic
        function togglePlayback() {
            isPlaying = !isPlaying;
            document.getElementById('play-btn').textContent = isPlaying ? '⏸ Pause' : '▶ Play';
            if (isPlaying) animate();
        }
        
        function animate() {
            if (!isPlaying) return;
            
            animationTime += maxTime / 200; // Speed factor
            if (animationTime > maxTime) animationTime = 0;
            
            updatePlaybackVisuals();
            animationFrame = requestAnimationFrame(animate);
        }
        
        function seek(e) {
            const rect = e.currentTarget.getBoundingClientRect();
            const pct = (e.clientX - rect.left) / rect.width;
            animationTime = pct * maxTime;
            updatePlaybackVisuals();
        }
        
        function updatePlaybackVisuals() {
            document.getElementById('progress').style.width = (animationTime / maxTime * 100) + '%';
            document.getElementById('time-display').textContent = (animationTime / 1000).toFixed(1) + 's';
            
            // Highlight active nodes
            graphData.nodes.forEach(n => {
                const el = document.getElementById(`node-${n.id}`);
                if (n.relativeStart <= animationTime && (n.relativeEnd || n.relativeStart + 100) >= animationTime) {
                    el.classList.add('active');
                } else {
                    el.classList.remove('active');
                }
                
                // Dim future nodes
                if (n.relativeStart > animationTime) {
                    el.classList.add('dimmed');
                } else {
                    el.classList.remove('dimmed');
                }
            });
        }
        
        init();
    </script>
</body>
</html>