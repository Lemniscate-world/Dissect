<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dissect - {title}</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-deep: #05050a;
            --panel-bg: rgba(13, 13, 22, 0.7);
            --accent-primary: #00d4ff;
            --accent-secondary: #7000ff;
            --accent-amber: #ffaa00;
            --text-main: #e0e0e6;
            --text-dim: #9494a3;
            --glass-border: rgba(255, 255, 255, 0.08);
            --node-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-font-smoothing: antialiased; }

        body {
            font-family: 'Outfit', sans-serif;
            background-color: var(--bg-deep);
            color: var(--text-main);
            height: 100vh;
            overflow: hidden;
            position: relative;
        }

        /* Animated Mesh Gradient Background */
        .mesh-bg {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: -1;
            background:
                radial-gradient(at 0% 0%, hsla(230, 40%, 15%, 1) 0, transparent 50%),
                radial-gradient(at 50% 0%, hsla(260, 50%, 10%, 1) 0, transparent 50%),
                radial-gradient(at 100% 0%, hsla(200, 60%, 15%, 1) 0, transparent 50%),
                radial-gradient(at 100% 100%, hsla(230, 40%, 10%, 1) 0, transparent 50%),
                radial-gradient(at 0% 100%, hsla(260, 50%, 12%, 1) 0, transparent 50%);
            filter: blur(80px);
            opacity: 0.6;
            animation: meshFlow 20s ease infinite alternate;
        }

        @keyframes meshFlow {
            0% { transform: scale(1); }
            100% { transform: scale(1.1); translate: 20px -20px; }
        }

        header {
            position: fixed;
            top: 20px; left: 20px; right: 20px;
            height: 64px;
            background: var(--panel-bg);
            backdrop-filter: blur(20px) saturate(180%);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 24px;
            z-index: 1000;
            box-shadow: var(--node-shadow);
        }

        header h1 { font-size: 1.4rem; font-weight: 700; letter-spacing: -0.02em; }
        header h1 span { color: var(--accent-primary); }

        .controls { display: flex; gap: 12px; }

        button {
            background: rgba(255,255,255,0.05);
            border: 1px solid var(--glass-border);
            color: var(--text-main);
            padding: 8px 18px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 600;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-family: inherit;
        }

        button:hover {
            background: rgba(255,255,255,0.1);
            border-color: rgba(255,255,255,0.2);
            transform: translateY(-1px);
        }

        button.primary {
            background: var(--accent-primary);
            color: #000;
            border: none;
            box-shadow: 0 4px 15px rgba(0, 212, 255, 0.3);
        }

        button.primary:hover {
            background: #fff;
            box-shadow: 0 6px 20px rgba(0, 212, 255, 0.5);
        }

        .container {
            display: flex;
            height: 100vh;
            padding-top: 100px;
            position: relative;
        }

        #graph-viewport {
            flex: 1;
            position: relative;
            overflow: hidden;
            cursor: grab;
        }

        #graph-viewport:active { cursor: grabbing; }

        #graph-content {
            position: absolute;
            top: 0; left: 0;
            transform-origin: 0 0;
            pointer-events: none;
        }

        #sidebar {
            width: 360px;
            margin: 0 20px 20px 0;
            background: var(--panel-bg);
            backdrop-filter: blur(20px) saturate(180%);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            padding: 24px;
            overflow-y: auto;
            z-index: 100;
            box-shadow: var(--node-shadow);
        }

        .node {
            position: absolute;
            padding: 16px 20px;
            border-radius: 14px;
            cursor: pointer;
            pointer-events: auto;
            min-width: 200px;
            font-size: 0.9rem;
            box-shadow: var(--node-shadow);
            border: 1px solid rgba(255,255,255,0.1);
            transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1), box-shadow 0.4s, opacity 0.4s;
            background: rgba(255,255,255,0.03);
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .node:hover {
            transform: scale(1.05) translateY(-5px);
            box-shadow: 0 20px 40px rgba(0,0,0,0.6);
            z-index: 100;
            border-color: rgba(255,255,255,0.3);
        }

        .node.selected {
            border: 2px solid var(--accent-primary);
            box-shadow: 0 0 30px rgba(0,212,255,0.4);
        }

        .node::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            border-radius: inherit;
            background: radial-gradient(circle at top left, rgba(255,255,255,0.1), transparent);
            pointer-events: none;
        }

        .node .type-badge {
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            font-weight: 700;
            opacity: 0.8;
            padding: 2px 8px;
            border-radius: 4px;
            width: fit-content;
            background: rgba(0,0,0,0.2);
        }

        /* High-End Node Gradients */
        .node-agent { background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%); }
        .node-tool { background: linear-gradient(135deg, #d4145a 0%, #fbb03b 100%); }
        .node-llm_call { background: linear-gradient(135deg, #662d8c 0%, #ed1e79 100%); }
        .node-user_input { background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); }
        .node-output { background: linear-gradient(135deg, #ff4e50 0%, #f9d423 100%); }

        .node .name { font-weight: 700; color: #fff; overflow: hidden; text-overflow: ellipsis; }
        .node .duration { font-family: 'JetBrains Mono', monospace; font-size: 0.75rem; color: rgba(255,255,255,0.6); }

        svg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; overflow: visible; }

        /* Path Styling */
        svg path {
            stroke: rgba(255,255,255,0.15);
            stroke-width: 2.5;
            fill: none;
            transition: stroke 0.4s, stroke-width 0.4s;
        }

        svg path.active {
            stroke: var(--accent-primary);
            stroke-width: 4;
            filter: drop-shadow(0 0 8px var(--accent-primary));
        }

        /* Data Flow Pulse Animation */
        .flow-pulse {
            fill: var(--accent-primary);
            filter: blur(3px) drop-shadow(0 0 5px var(--accent-primary));
            opacity: 0;
        }

        .active-pulse { opacity: 1; }

        .info-panel h3 { margin-bottom: 1.5rem; color: var(--accent-primary); font-size: 1rem; text-transform: uppercase; letter-spacing: 0.15em; font-weight: 700; }

        .info-item {
            margin-bottom: 12px;
            background: rgba(255,255,255,0.03);
            padding: 16px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.05);
        }

        .info-item label { font-size: 0.75rem; color: var(--text-dim); text-transform: uppercase; letter-spacing: 0.05em; display: block; margin-bottom: 6px; }
        .info-item span { font-size: 1rem; font-weight: 600; color: #fff; }

        .playback-bar {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--panel-bg);
            backdrop-filter: blur(25px) saturate(200%);
            padding: 12px 30px;
            border-radius: 24px;
            display: flex;
            align-items: center; gap: 20px; border: 1px solid var(--glass-border); z-index: 1000; box-shadow: 0 10px 40px rgba(0,0,0,0.5); }
        .progress-container { width: 400px; height: 10px; background: rgba(255,255,255,0.1); border-radius: 5px; cursor: pointer; position: relative; overflow: hidden; }
        .progress-bar { height: 100%; background: linear-gradient(90deg, var(--accent-secondary), var(--accent-primary)); border-radius: 5px; width: 0%; transition: width 0.1s linear; }
        .time-display { font-family: 'JetBrains Mono', monospace; font-size: 0.9rem; font-weight: 500; min-width: 70px; color: var(--accent-primary); }
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background: rgba(255,255,255,0.2); }
    </style>
</head>
<body>
    <div class="mesh-bg"></div>
    <header>
        <h1><span>Dissect</span> {title}</h1>
        <div class="controls">
            <button onclick="resetZoom()">Focus Graph</button>
            <button id="heat-btn" onclick="toggleHeatmap()">Activity Heatmap</button>
        </div>
    </header>
    <div class="container">
        <div id="graph-viewport">
            <div id="graph-content">
                <svg id="edges-layer"></svg>
                <div id="nodes-layer"></div>
            </div>
        </div>
        <div id="sidebar">
            <div class="info-panel">
                <h3>Workflow Analytics</h3>
                <div class="info-item">
                    <label>Orchestration Steps</label>
                    <span id="info-nodes">{node_count}</span>
                </div>
                <div class="info-item">
                    <label>Critical Latency</label>
                    <span id="info-duration">{critical_duration}ms</span>
                </div>
            </div>
            <div id="node-details" style="display:none; margin-top: 2rem;">
                <h3>Node Intelligence</h3>
                <div class="info-item">
                    <label>Identity</label>
                    <span id="detail-name">-</span>
                </div>
                <div class="info-item">
                    <label>Category</label>
                    <span id="detail-type">-</span>
                </div>
                <div class="info-item">
                    <label>Latency</label>
                    <span id="detail-duration">-</span>
                </div>
                <div class="info-item">
                    <label>Context Data</label>
                    <pre id="detail-meta" style="font-family:'JetBrains Mono', monospace; font-size:0.75rem; margin-top: 10px; color: var(--text-dim); overflow-x: auto;">-</pre>
                </div>
            </div>
        </div>
    </div>
    <div class="playback-bar">
        <button id="play-btn" class="primary" onclick="togglePlayback()">Start Trace</button>
        <div class="progress-container" onclick="seek(event)">
            <div class="progress-bar" id="progress"></div>
        </div>
        <div class="time-display" id="time-display">0.0s</div>
    </div>
    <script>
        const graphData = {graph_json};
        const viewport = document.getElementById('graph-viewport');
        const content = document.getElementById('graph-content');
        const svgLayer = document.getElementById('edges-layer');
        const nodesContainer = document.getElementById('nodes-layer');
        let scale = 0.8;
        let pannedX = 0;
        let pannedY = 0;
        let isDragging = false;
        let startX, startY;
        let isPlaying = false;
        let isHeatmapMode = false;
        let animationTime = 0;
        let maxTime = 0;
        let animationFrame;
        function init() {
            const timestamps = graphData.nodes.map(n => [n.start_time, n.end_time]).flat().filter(t => t);
            if (timestamps.length > 0) {
                const minTime = Math.min(...timestamps);
                graphData.nodes.forEach(n => {
                    if (n.start_time) n.relativeStart = (n.start_time - minTime) * 1000;
                    if (n.end_time) n.relativeEnd = (n.end_time - minTime) * 1000;
                });
                maxTime = Math.max(...graphData.nodes.map(n => n.relativeEnd || 0));
            } else {
                graphData.nodes.forEach((n, i) => {
                    n.relativeStart = i * 200;
                    n.relativeEnd = (i + 1) * 200;
                });
                maxTime = graphData.nodes.length * 200;
            }
            renderGraph();
            centerGraph();
            setupEvents();
        }
        function renderGraph() {
            const levels = {};
            const nodeMap = {};
            graphData.nodes.forEach(n => nodeMap[n.id] = n);
            const targets = new Set(graphData.edges.map(e => e.target));
            const roots = graphData.nodes.filter(n => !targets.has(n.id));
            const queue = roots.map(r => ({ id: r.id, level: 0 }));
            const visited = new Set();
            while (queue.length > 0) {
                const { id, level } = queue.shift();
                if (visited.has(id)) continue;
                visited.add(id);
                if (!levels[level]) levels[level] = [];
                levels[level].push(id);
                graphData.edges.filter(e => e.source === id).forEach(e => {
                    queue.push({ id: e.target, level: level + 1 });
                });
            }
            const hGap = 260;
            const vGap = 200;
            const nodePositions = {};
            Object.entries(levels).forEach(([level, ids]) => {
                const width = ids.length * hGap;
                ids.forEach((id, i) => {
                    const x = (i * hGap) - (width / 2) + (hGap/2);
                    const y = level * vGap + 80;
                    nodePositions[id] = { x, y };
                    const node = nodeMap[id];
                    const div = document.createElement('div');
                    div.className = `node node-${node.type}`;
                    div.id = `node-${id}`;
                    div.style.left = x + 'px';
                    div.style.top = y + 'px';
                    div.innerHTML = `
                        <div class="type-badge">${node.type.replace('_',' ')}</div>
                        <div class="name">${node.name}</div>
                        ${node.duration_ms ? `<div class="duration">${node.duration_ms.toFixed(0)}ms</div>` : ''}
                    `;
                    div.onclick = (e) => {
                        document.querySelectorAll('.node').forEach(n => n.classList.remove('selected'));
                        div.classList.add('selected');
                        document.getElementById('node-details').style.display = 'block';
                        document.getElementById('detail-name').textContent = node.name;
                        document.getElementById('detail-type').textContent = node.type;
                        document.getElementById('detail-duration').textContent = node.duration_ms ? node.duration_ms.toFixed(0) + 'ms' : '-';
                        document.getElementById('detail-meta').textContent = JSON.stringify(node.metadata, null, 2);
                    };
                    nodesContainer.appendChild(div);
                });
            });
            graphData.edges.forEach(edge => {
                const start = nodePositions[edge.source];
                const end = nodePositions[edge.target];
                if (start && end) {
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    const sx = start.x + 100;
                    const sy = start.y + 60;
                    const ex = end.x + 100;
                    const ey = end.y;
                    const cp = (ey - sy) / 2;
                    const d = `M ${sx} ${sy} C ${sx} ${sy + cp}, ${ex} ${ey - cp}, ${ex} ${ey}`;
                    path.setAttribute('d', d);
                    path.id = `edge-${edge.source}-${edge.target}`;
                    svgLayer.appendChild(path);
                    const pulse = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    pulse.setAttribute('r', '5');
                    pulse.classList.add('flow-pulse');
                    pulse.id = `pulse-${edge.source}-${edge.target}`;
                    svgLayer.appendChild(pulse);
                    const animate = document.createElementNS('http://www.w3.org/2000/svg', 'animateMotion');
                    animate.setAttribute('dur', '1.5s');
                    animate.setAttribute('repeatCount', 'indefinite');
                    animate.setAttribute('path', d);
                    pulse.appendChild(animate);
                }
            });
        }
        function setupEvents() {
            viewport.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                scale = Math.min(Math.max(0.1, scale * delta), 4);
                updateT();
            });
            viewport.addEventListener('mousedown', (e) => {
                if (e.target.closest('.node')) return;
                isDragging = true;
                startX = e.clientX - pannedX;
                startY = e.clientY - pannedY;
            });
            window.addEventListener('mouseup', () => isDragging = false);
            window.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    pannedX = e.clientX - startX;
                    pannedY = e.clientY - startY;
                    updateT();
                }
            });
        }
        function updateT() { content.style.transform = `translate(${pannedX}px, ${pannedY}px) scale(${scale})`; }
        function centerGraph() { pannedX = viewport.offsetWidth / 2 - 100; pannedY = 40; updateT(); }
        function resetZoom() { centerGraph(); scale = 0.8; updateT(); }
        function togglePlayback() {
            isPlaying = !isPlaying;
            document.getElementById('play-btn').textContent = isPlaying ? 'Pause Trace' : 'Resume Trace';
            if (isPlaying) loop();
        }
        function loop() {
            if (!isPlaying) return;
            animationTime += maxTime / 300;
            if (animationTime > maxTime) animationTime = 0;
            updateUI();
            animationFrame = requestAnimationFrame(loop);
        }
        function seek(e) {
            const pct = (e.clientX - e.currentTarget.getBoundingClientRect().left) / e.currentTarget.offsetWidth;
            animationTime = pct * maxTime;
            updateUI();
        }
        function updateUI() {
            document.getElementById('progress').style.width = (animationTime / maxTime * 100) + '%';
            document.getElementById('time-display').textContent = (animationTime / 1000).toFixed(1) + 's';
            graphData.nodes.forEach(n => {
                const el = document.getElementById(`node-${n.id}`);
                const active = n.relativeStart <= animationTime && (n.relativeEnd || n.relativeStart + 200) >= animationTime;
                el.style.opacity = n.relativeStart > animationTime ? '0.2' : '1';
                el.style.transform = active ? `scale(1.1) translateY(-10px)` : '';
                if (active) el.style.boxShadow = '0 0 40px ' + (getComputedStyle(el).backgroundColor);
                else el.style.boxShadow = '';
            });
            graphData.edges.forEach(e => {
                const p = document.getElementById(`pulse-${e.source}-${e.target}`);
                const edge = document.getElementById(`edge-${e.source}-${e.target}`);
                const sourceNode = graphData.nodes.find(n => n.id === e.source);
                const active = sourceNode.relativeStart <= animationTime && (sourceNode.relativeEnd || sourceNode.relativeStart + 500) >= animationTime;
                p.style.opacity = active ? '1' : '0';
                edge.classList.toggle('active', active);
            });
        }
        function toggleHeatmap() {
            isHeatmapMode = !isHeatmapMode;
            document.getElementById('heat-btn').classList.toggle('primary', isHeatmapMode);
            graphData.nodes.forEach(n => {
                const el = document.getElementById(`node-${n.id}`);
                if (isHeatmapMode) {
                    const h = 120 * (1 - (n.heat_score || 0));
                    el.style.background = `linear-gradient(135deg, hsl(${h}, 70%, 45%), hsl(${h}, 70%, 30%))`;
                } else el.style.background = '';
            });
        }
        init();
    </script>
</body>
</html>
